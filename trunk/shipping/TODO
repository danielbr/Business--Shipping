######################################################
##  General TODO
######################################################
 
 * Only Cache the response if it was a success (very important)
 
 * Re-do the self meta-data, I think it's buggy.
 
 * Error on missing arguments isn't working very well ( user_id, password)
 
 * include the terms of use for each module.
 
 * The Shipping module itself should be able to be queried for what shippers it
   handles. Each shipper should be able to be queried for what services it 
   provides... maybe code would look like this:

	use Business::Shippingping; 
	
	# Query the module for installed shipper specific modules.
	my @shippers = Business::Shippingping::available_shippers(); 
	
	my %shipping_option; 
	for my $shipper (@shippers) { 
	
		# Services would be Ground, 2nd day air, things like that.
		my @services = $shipper->services();
	 
		for my $service (@services) { 
	
			# The $package would have been previously generated.
			$shipping_option{$shipper->name}->{$service} =
				$shipper->rate($service, $package); 
	
		}
	}
 
 * Country name translator strings to data outside your program.
 
 * Perhaps pull the shipper-related stuff out of Business::Shipping into Business::Shippingper. 
 	- Then Packages can inherit all of the sub building, debugging, etc. functions from
	  Business::Shipping.  USPS and UPS will then inherit what they need from Business::Shippingper.
	- Business::Shippingper would also be @ISA=Business::Shipping.
	- Should be done without breaking backwards-compatibility.
 
 * Upgrade the debugging/error handling features: allow user to pass in a callback ref.
 
 * Documentation
 
 * Business::Shipping::FedEx module
 	- Utilize the recently released Business::FedEx::DirectConnect module.

 * More flexible handling of SSL?
	- Allow the use of Net::SSLeay as well as Crypt::SSLeay?

 * Business::Shipping::OldUPS interface?
 	- Utilize Business::UPS?  Advantage:  no username/id...
	
 * New feature ideas:
 	- Address Verification
	- Package Tracking
	- Service Availability
 	
 * Testing code needs a lot of work.
 
 * Use Params::Validate for parameter validation?
 
 * List Prerequisites in a Bundle module
 
 * Documentation: explain what else is out there (Business::UPS, FedEx, static table lookup)
 
 * So, it sounds like a "shipment" is another useful abstraction. It would be 
   shipper-specific and so you probably would have a 
   Business::Shippingping::<carrier>::Shipment package defined for each carrier. 
   A shipment would contain one or more packages. It would have an origin or 
   destination just as the packages it contains. In fact, you'd probably want 
   to assert that the packages in a shipment all had the same origins and 
   destinations. The shipment would have a schedule attached to it. You'd 
   likely track the shipment (rather than tracking a package.) I suspect 
   you would want to avoid instantiating a Shipment until after one is 
   actually scheduled; you shouldn't need these classes to determine the 
   shipping rates.
   
 * A more effecient cacheing method:
   - Cache the end-result (amounts, etc), then look it up at submit() time based on the
     same _unique_values.  Would require that ignore_extra_info=1, so that all the country
     information (customs, etc.) wouldn't be saved (kb on disk).
   - More efficient methods besides FileCache?


 
######################################################
##  Interchange usertags TODO
######################################################

 * Test for ability to use within Safe?
	([perl]$Tag->ups_query('', '', '');[/perl]) 
	
######################################################
##  Business::Shipping::USPS TODO
######################################################

 * Not correctly realizing when there is an error (<Error><Number>...)
   - Perhaps because we don't ( KeepRoot => 1, ) on the XMLin()?

 * Pull the test cases & responses out of the PDF docs and program them so 
   that they are a test case (commonly in the /t directory in most CPAN  
   modules) so that a user can plug their username and password in the 
   script, or via the build process and test that their account is 
   accepting data correctly.
   
 * Identify the different USPS interfaces (Standard Mail (what we're 
   working on), Priority Mail, International, ?Others? and pull the specs
   from the PDF's on how to structure the requests and parse the responses.
   
 * Support get_charges( 'service' ) for domestic types.

######################################################
##  Business::Shipping::UPS TODO
######################################################
 
 * Tests that *I* should run:

	- All types (ground, air, etc.) 
	- World wide (several countries, states (Hawaii, Alaska), etc.)
	- Confirm that price returned > 0, and no error.  (If error, fail test and dispaly error).

 * Confirm thread-safety-ness.

 * Is non-ssl communication with either provider possible?	

 * Be able to handle "mal-formed XML doc" error return from UPS.  
 	- Right now, it still tries to parse as an XML doc.
 
 * UPS support for sending multiple simultaneous requests
	- (USPS had built-in support in the API for Intl)
 	- If they don't support it, try LWP::Parallel::UserAgent.
