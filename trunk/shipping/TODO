######################################################
##  General TODO
######################################################
  
 * Bug Report:
   - When the internet is down, we should report a more useful error message
     than this:
	 Business::Shipping::RateRequest::Online::USPS::_handle_response: ()
     File does not exist:  at .../RateRequest/Online/USPS.pm line 202

 * FedEx module: Christopher L Wenham from Synesmedia has created an Interchange
   usertag that uses FedEx::DirectConnect for various functions.
 
 * Enable Cache for USPS.
 
 * Find a better way to correlate "Air mail" with all the various names
   it is called by each country.

 * Fix the multi-package API for UPS.  
   # TODO: Move to a different XML generation scheme, since all the packages 
   #       in a multi-package shipment will have the name "Package".
   # TODO: multi-package support: loop over the packages
 
 * Migrate the "retry on failure" code from business-shipping.tag to 
   Business::Shipping proper.  Default to tries=2, but allow that to be
   overridden.  (HTTP 500 errors.)
 
 * Only Cache the response if it was a success (very important)
 
 * Error on missing arguments isn't working very well ( user_id, password)
 
 * The Shipping module itself should be able to be queried for what shippers it
   handles. Each shipper should be able to be queried for what services it 
   provides... maybe code would look like this:

	use Business::Shipping; 
	
	# Query the module for installed shipper specific modules.
	my @shippers = Business::Shipping::available_shippers(); 
	
	my %shipping_option; 
	for my $shipper (@shippers) { 
	
		# Services would be Ground, 2nd day air, things like that.
		my @services = $shipper->services();
	 
		for my $service (@services) { 
	
			# The $package would have been previously generated.
			$shipping_option{$shipper->name}->{$service} =
				$shipper->rate($service, $package); 
	
		}
	}
 
 * Country name translator strings to data outside your program.
 	# TODO: Move all of this, and any other data that is currently mixed with 
	# code.
	# A simple, file-based configuration system would be nice, like Interchange.
	# Perhaps XML::Simple Configuration files?  Other?  Shipping::Config module
	# will provide parser, importer.  Any internal modules that use 
	# configuration will go through that module.  (it's an idea, anyway) 
 
 * Upgrade the debugging/error handling features: allow user to pass in a callback ref.
 
 * Documentation
   - Explain what else is out there (Business::UPS, FedEx, static table lookup)
   - Include the terms of use for each module.
 
 * Business::Shipping::FedEx module
 	- Utilize the recently released Business::FedEx::DirectConnect module.

 * More flexible handling of SSL?
	- Allow the use of Net::SSLeay as well as Crypt::SSLeay?

 * Business::Shipping::OldUPS?
	- Utilize the new Business::Shipping::UPS?
	
 * New feature ideas:
 	- Address Verification
	- Shipping status (package tracking)
	- Service Availability
	- Electronic Merchandise Return?
	- Shipping label generation?
	- Customs forms?
	- Shipping time (how long till it gets there)?
	- Delivery/Signature confirmation?
 	
 * Use Params::Validate for parameter validation?
 
 * List Prerequisites in a Bundle module
 
 * So, it sounds like a "shipment" is another useful abstraction. It would be 
   shipper-specific and so you probably would have a 
   Business::Shippingping::<carrier>::Shipment package defined for each carrier. 
   A shipment would contain one or more packages. It would have an origin or 
   destination just as the packages it contains. In fact, you'd probably want 
   to assert that the packages in a shipment all had the same origins and 
   destinations. The shipment would have a schedule attached to it. You'd 
   likely track the shipment (rather than tracking a package.) I suspect 
   you would want to avoid instantiating a Shipment until after one is 
   actually scheduled; you shouldn't need these classes to determine the 
   shipping rates.
   
 * Cache Enhancements:
   - Cache the end-result (amounts, etc), then look it up at submit() time based
     on the same _unique_values.  Would require that ignore_extra_info=1, so 
	 that all the country information (customs, etc.) wouldn't be saved (kb on 
	 disk).
   - More efficient methods besides FileCache?

 * Why do I have to 'use' all the modules -- indicative of a bug?
   
######################################################
##  Business::Shipping::USPS TODO
######################################################

 * Not correctly realizing when there is an error (<Error><Number>...)
   - Perhaps because we don't ( KeepRoot => 1, ) on the XMLin()?

 * Pull the test cases & responses out of the PDF docs and program them so 
   that they are a test case (commonly in the /t directory in most CPAN  
   modules) so that a user can plug their username and password in the 
   script, or via the build process and test that their account is 
   accepting data correctly.
     
 * Support get_charges( 'service' ) for domestic types.

######################################################
##  Business::Shipping::UPS TODO
######################################################
 
 * Allow better names, like "One Day Air" instead of 1DA.
   Better names for packaging too (instead of numbers).
 
 * Tests:
	- All types (ground, air, etc.) 
	- World wide (several countries, states (Hawaii, Alaska), etc.)

 * Test for thread-safety-ness.

 * Is non-ssl communication with either provider possible?	

 * Be able to handle "mal-formed XML doc" error return from UPS.  
 	- Right now, it still tries to parse as an XML doc.
 
 * UPS support for sending multiple simultaneous requests
	- (USPS had built-in support in the API for Intl)
 	- If they don't support it, try LWP::Parallel::UserAgent.

######################################################
##  Interchange UserTag TODO
######################################################

 * Test for ability to use within Safe?
	([perl]$Tag->ups_query('', '', '');[/perl]) 
